// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.6/esri/copyright.txt for details.
//>>built
require({cache:{"url:esri/views/3d/webgl-engine/materials/Material.xml":'\x3c?xml version\x3d"1.0" encoding\x3d"UTF-8"?\x3e\r\n\r\n\x3csnippets\x3e\r\n\r\n\x3csnippet name\x3d"calculateVerticalOffset"\x3e\x3c![CDATA[\r\n  $viewingMode\r\n\r\n#ifdef VERTICAL_OFFSET\r\n  // [ verticalOffsetPerDistance, minWorldLength, maxWorldLength ]\r\n  uniform vec4 verticalOffset;\r\n\r\n#ifdef SCREEN_SIZE_PERSPECTIVE\r\n\r\n  uniform vec4 screenSizePerspectiveAlignment;\r\n\r\n  $screenSizePerspective\r\n\r\n#endif\r\n\r\n  vec3 calculateVerticalOffset(vec3 worldPos, vec3 localOrigin) {\r\n    float viewDistance \x3d length((view * vec4(worldPos, 1)).xyz);\r\n    float verticalOffsetOffsetDistance \x3d verticalOffset.x * viewDistance;\r\n\r\n#ifdef VIEWING_MODE_GLOBAL\r\n    vec3 worldNormal \x3d normalize(worldPos + localOrigin);\r\n#else\r\n    vec3 worldNormal \x3d vec3(0, 0, 1);\r\n#endif\r\n\r\n#ifdef SCREEN_SIZE_PERSPECTIVE\r\n    float cosAngle \x3d dot(worldNormal, normalize(worldPos - camPos));\r\n\r\n    float verticalOffsetScreenHeight \x3d screenSizePerspectiveScaleFloat(verticalOffset.x, abs(cosAngle), viewDistance, screenSizePerspectiveAlignment);\r\n#else\r\n    float verticalOffsetScreenHeight \x3d verticalOffset.x;\r\n#endif\r\n\r\n    // Screen sized offset in world space, used for example for line callouts\r\n    float worldOffset \x3d clamp(verticalOffsetScreenHeight * verticalOffset.y * viewDistance, verticalOffset.z, verticalOffset.w);\r\n\r\n    return worldNormal * worldOffset;\r\n  }\r\n#endif\r\n]]\x3e\r\n\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsPhongSrc"\x3e\x3c![CDATA[\r\n\tuniform mat4 proj;\r\n\tuniform mat4 view;\r\n  uniform vec3 camPos;\r\n\r\n\tuniform vec3 localOrigin;\r\n\r\n#ifdef INSTANCED\r\n    attribute mat4 model;\r\n    attribute mat4 modelNormal;\r\n#else\r\n\tuniform mat4 model;\r\n\tuniform mat4 modelNormal;\r\n#endif\r\n#ifdef INSTANCEDCOLOR\r\n\tattribute vec4 instanceColor;\r\n#endif\r\n\tattribute vec3 $position;\r\n\tattribute vec3 $normal;\r\n\tvarying vec3 vpos;\r\n\tvarying vec3 vnormal;\r\n\r\n#ifdef RECEIVE_SHADOWS\r\n\tvarying float linearDepth;\r\n#endif\r\n\r\n#ifdef VERTEXCOLORS\r\n\tattribute vec4 $color;\r\n#endif\r\n\r\n#ifdef SYMBOLVERTEXCOLORS\r\n  attribute vec4 $symbolColor;\r\n#endif\r\n\r\n#if defined(VV_SIZE) || defined(VV_COLOR)\r\n\tattribute vec4 instanceFeatureAttribute;\r\n#endif\r\n\r\n$vvUniforms\r\n\r\n#if defined(VERTEXCOLORS)\r\n\tvarying vec4 vcolor;\r\n#endif\r\n\r\n#if defined(INSTANCEDCOLOR) || defined(VV_COLOR) || defined(SYMBOLVERTEXCOLORS)\r\n\tuniform vec4 externalColor;\r\n\tvarying vec4 vcolorExt;\r\n#endif\r\n\r\n#if defined(SYMBOLVERTEXCOLORS)\r\n\tvarying mediump float colorMixMode; // varying int is not supported in WebGL\r\n#endif\r\n\r\n\t$vvFunctions\r\n\r\n\t$colorMixMode\r\n\r\n  $calculateVerticalOffset\r\n\r\n\tvoid main(void) {\r\n\r\n#ifdef VV_CUSTOM_MODEL_MATRIX\r\n\r\n\t\tvpos \x3d (model * vvTransformPosition($position, instanceFeatureAttribute)).xyz;\r\n\t\tvnormal \x3d normalize((modelNormal * vvTransformNormal($normal, instanceFeatureAttribute)).xyz);\r\n\r\n#ifdef VERTICAL_OFFSET\r\n\t\tvec3 centerPos \x3d (model * vvTransformPosition(vec3(0, 0, 0), instanceFeatureAttribute)).xyz;\r\n#endif\r\n\r\n#else /* VV_CUSTOM_MODEL_MATRIX */\r\n\r\n\t\tvpos \x3d (model * vec4($position, 1.0)).xyz;\r\n\t\tvnormal \x3d normalize((modelNormal * vec4($normal, 1.0)).xyz);\r\n\r\n#ifdef VERTICAL_OFFSET\r\n\t\tvec3 centerPos \x3d (model * vec4(vec3(0, 0, 0), 1.0)).xyz;\r\n#endif\r\n\r\n#endif /* VV_CUSTOM_MODEL_MATRIX */\r\n\r\n#ifdef VERTICAL_OFFSET\r\n    vpos +\x3d calculateVerticalOffset(centerPos, localOrigin);\r\n#endif\r\n\r\n\t\tgl_Position \x3d proj * view * vec4(vpos, 1.0);\r\n\r\n#ifdef RECEIVE_SHADOWS\r\n\t\t// Shadowmap\'s cascading index used to be based on \'1.0 / gl_FragCoord.w\'\r\n\t\t// (i.e. the perspective interpolation of \'gl_Position.w\'). Precision\r\n\t\t// issues on iPad/iPhone with the \'w\' component require the depth to be\r\n\t\t// passed as varying to properly drive the cascading shadow map index.\r\n\t\tlinearDepth \x3d gl_Position.w;\r\n#endif\r\n\r\n#ifdef VERTEXCOLORS\r\n\t\tvcolor \x3d $color * 0.003921568627451; // \x3d 1/255\r\n#endif\r\n\r\n#if defined(INSTANCEDCOLOR) || defined(VV_COLOR) || defined(SYMBOLVERTEXCOLORS)\r\n\t\tvcolorExt \x3d externalColor;\r\n#endif\r\n#ifdef INSTANCEDCOLOR\r\n\t\tvcolorExt *\x3d instanceColor;\r\n#endif\r\n#ifdef VV_COLOR\r\n\t\tvcolorExt *\x3d vvGetColor(instanceFeatureAttribute, vvColorValues, vvColorColors);\r\n#endif\r\n#ifdef SYMBOLVERTEXCOLORS\r\n    int symbolColorMixMode;\r\n    vcolorExt *\x3d decodeSymbolColor(symbolColor, symbolColorMixMode) * 0.003921568627451; // \x3d 1/255;\r\n    colorMixMode \x3d float(symbolColorMixMode) + 0.5; // add 0.5 to avoid interpolation artifacts\r\n#endif\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsPhongSrc"\x3e\x3c![CDATA[\r\n  $fsprecisionf\r\n\r\n\tuniform vec3 camPos;\r\n\tuniform vec3 localOrigin;\r\n\r\n\t$sceneLightingDefinitions\r\n\r\n\t// material parameters\r\n\t//////////////////////////////////////////\r\n\tuniform vec3 ambient;\r\n\tuniform vec3 diffuse;\r\n\tuniform vec3 specular;\r\n\tuniform float shininess;\r\n\tuniform float opacity;\r\n\tuniform float layerOpacity;\r\n\r\n#ifdef SYMBOLVERTEXCOLORS\r\n\tvarying mediump float colorMixMode; // varying int is not supported in WebGL\r\n#else\r\n  uniform int colorMixMode;\r\n#endif\r\n\r\n#ifdef RECEIVE_SHADOWS\r\n\tuniform sampler2D depthTex;\r\n\tuniform int shadowMapNum;\r\n\tuniform vec4 shadowMapDistance;\r\n\tuniform mat4 shadowMapMatrix[4];\r\n\tuniform float depthHalfPixelSz;\r\n#endif\r\n\r\n#ifdef RECEIVE_SSAO\r\n\tuniform sampler2D ssaoTex;\r\n\tuniform vec4 viewportPixelSz;\r\n#endif\r\n\r\n\r\n\tvarying vec3 vpos;\r\n\tvarying vec3 vnormal;\r\n#if defined(VERTEXCOLORS)\r\n\tvarying vec4 vcolor;\r\n#endif\r\n#if defined(INSTANCEDCOLOR) || defined(VV_COLOR) || defined(SYMBOLVERTEXCOLORS)\r\n\tvarying vec4 vcolorExt;\r\n#else\r\n\tuniform vec4 externalColor;\r\n#endif\r\n\r\n#ifdef RECEIVE_SHADOWS\r\n\tvarying float linearDepth;\r\n\t$evalShadow\r\n#endif\r\n\r\n\t$colorMixMode\r\n\r\n\tvoid main() {\r\n\t\tvec3 viewDir \x3d normalize(vpos - camPos);\r\n\r\n\t\t$computeNormal\r\n\r\n\t\tvec3 reflDir \x3d normalize(reflect(viewDir, normal));\r\n\r\n\t\t// compute ssao\r\n\t\t#ifdef RECEIVE_SSAO\r\n\t\t\t\tfloat ssao \x3d texture2D(ssaoTex, (gl_FragCoord.xy - viewportPixelSz.xy) * viewportPixelSz.zw).a;\r\n\t\t\t\tssao \x3d viewportPixelSz.z \x3c 0.0 ? 1.0 : ssao;\r\n\t\t#else\r\n\t\t\t\tfloat ssao \x3d 1.0;\r\n\t\t#endif\r\n\r\n\t\t// At global scale we create some additional ambient light based on the main light to simulate global illumination\r\n\t\t// This also defines "additionalAmbientScale" which might be used as a shadow fallback further down\r\n\t\t$sceneLightingAdditionalLightGlobal\r\n\r\n\t\t// compute shadowing\r\n\t\tfloat shadow \x3d 0.0;\r\n\t\t#ifdef RECEIVE_SHADOWS\r\n\t\t\tshadow \x3d evalShadow(vpos, linearDepth, depthTex, shadowMapNum, shadowMapDistance, shadowMapMatrix, depthHalfPixelSz);\r\n\t\t#elif defined(VIEWING_MODE_GLOBAL)\r\n\t\t\t// at global scale (and in global scenes) we fall back to this approximation\r\n\t\t\t// to shadow objects on the dark side of the earth\r\n\t\t\tshadow \x3d lightingGlobalFactor * (1.0 - additionalAmbientScale);\r\n\t\t#endif\r\n\r\n\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"externalColorMix"\x3e\x3c![CDATA[\r\n\tvec3 matColor \x3d max(ambient, diffuse); // combine the old material parameters into a single one\r\n\t#if defined(VERTEXCOLORS) \x26\x26 (defined(INSTANCEDCOLOR) || defined(VV_COLOR) || defined(SYMBOLVERTEXCOLORS))\r\n\t\t\t// Internal colors: varying vcolor + uniform ambient/diffuse, external colors: varying vcolorExt\r\n\t\t\tvec3 albedo_ \x3d mixExternalColor(vcolor.rgb * matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\r\n\t\t\tfloat opacity_ \x3d layerOpacity * mixExternalOpacity(vcolor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));\r\n\t#elif defined(VERTEXCOLORS)\r\n\t\t\t// Internal colors: varying vcolor + uniform ambient/diffuse, external colors: uniform externalColor\r\n\t\t\tvec3 albedo_ \x3d mixExternalColor(vcolor.rgb * matColor, texColor.rgb, externalColor.rgb, int(colorMixMode));\r\n\t\t\tfloat opacity_ \x3d layerOpacity * mixExternalOpacity(vcolor.a * opacity, texColor.a, externalColor.a, int(colorMixMode));\r\n\t#elif defined(INSTANCEDCOLOR) || defined(VV_COLOR) || defined(SYMBOLVERTEXCOLORS)\r\n\t\t\t// Internal colors: uniform ambient/diffuse, external colors: varying vcolorExt\r\n\t\t\tvec3 albedo_ \x3d mixExternalColor(matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\r\n\t\t\tfloat opacity_ \x3d layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));\r\n\t#else\r\n\t\t\t// Internal colors: uniform ambient/diffuse, external colors: uniform externalColor\r\n\t\t\tvec3 albedo_ \x3d mixExternalColor(matColor, texColor.rgb, externalColor.rgb, int(colorMixMode));\r\n\t\t\tfloat opacity_ \x3d layerOpacity * mixExternalOpacity(opacity, texColor.a, externalColor.a, int(colorMixMode));\r\n\t#endif\r\n\talbedo_+\x3d 0.25 * specular; // don\'t completely ignore specular for now\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsPhong"\x3e\x3c![CDATA[\r\n  $vsprecisionf\r\n\r\n\t$vsPhongSrc\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsPhong"\x3e\x3c![CDATA[\r\n\t\t$fsprecisionf\r\n\r\n\t\t$fsPhongSrc\r\n\r\n\t\tvec4 texColor \x3d vec4(1,1,1,1);\r\n\t\t$externalColorMix\r\n\r\n\t\tvec3 shadedColor \x3d evaluateSceneLighting(normal, albedo_, shadow, 1.0 - ssao, additionalLight);\r\n\t\tgl_FragColor \x3d vec4(shadedColor, opacity_);\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsPhongTextured"\x3e\x3c![CDATA[\r\n  $vsprecisionf\r\n\r\n\tattribute vec2 $uv0;\r\n\tvarying vec2 vtc;\r\n\t$vsPhongSrc\r\n#ifndef FLIPV\r\n\t\tvtc \x3d $uv0;\r\n#else\r\n\t\tvtc \x3d vec2($uv0.x, 1.0-$uv0.y);\r\n#endif\r\n\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsPhongTextured"\x3e\x3c![CDATA[\r\n\t$fsprecisionf\r\n\r\n\tuniform sampler2D tex;\r\n\tvarying vec2 vtc;\r\n\r\n\t$fsPhongSrc\r\n\r\n\t\t// read texture color\r\n\t\tvec4 texColor \x3d texture2D(tex, vtc);\r\n\t\tif (texColor.a \x3c .33) discard;\r\n\r\n\t\t$externalColorMix\r\n\r\n\t\tvec3 shadedColor \x3d evaluateSceneLighting(normal, albedo_, shadow, 1.0 - ssao, additionalLight);\r\n\r\n\t\tgl_FragColor \x3d vec4(shadedColor, opacity_);\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsPhongAtlasTextured"\x3e\x3c![CDATA[\r\n  $vsprecisionf\r\n\r\n\tattribute vec4 $uv0;\r\n\tattribute vec4 $region;\r\n\tvarying vec2 vtc;\r\n\tvarying vec4 regionV;\r\n\t$vsPhongSrc\r\n#ifndef FLIPV\r\n\t\tvtc \x3d $uv0.xy;\r\n#else\r\n\t\tvtc \x3d vec2($uv0.x, 1.0-$uv0.y);\r\n#endif\r\n\t\tregionV \x3d $region/65535.0;\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsPhongAtlasTextured"\x3e\x3c![CDATA[\r\n\t$fsprecisionf\r\n\r\n\tuniform sampler2D tex;\r\n\tuniform vec2 texSize;\r\n\tvarying vec2 vtc;\r\n\tvarying vec4 regionV;\r\n\r\n\tfloat calcMipMapLevel(const vec2 ddx, const vec2 ddy) {\r\n\t\t// from:\r\n\t\t//   - OpenGLES Common Profile Specification Version 2.0.25, Section 3.7.7 - Texture Minification\r\n\t\t//   - https://www.opengl.org/discussion_boards/showthread.php/171485-Texture-LOD-calculation-(useful-for-atlasing)\r\n\t\t//   - http://www.linedef.com/virtual-texture-demo.html\r\n\t\tfloat deltaMaxSqr \x3d max(dot(ddx, ddx), dot(ddy, ddy));\r\n\t\treturn max(0.5 * log2(deltaMaxSqr), 0.0);\r\n\t}\r\n\r\n\t$fsPhongSrc\r\n\r\n\t\tvec2 uv \x3d vtc;\r\n\t\tuv \x3d fract(uv);\r\n\t\t//[umin, vmin, umax, vmax]\r\n\r\n\t\tvec2 atlasScale \x3d regionV.zw - regionV.xy;\r\n\t\tuv \x3d uv.xy * atlasScale + regionV.xy;\r\n\r\n\t\tvec4 texColor;\r\n\t\t#ifdef GL_OES_standard_derivatives\r\n\t\t\t#extension GL_OES_standard_derivatives : enable\r\n\r\n\t\t\t// calculate derivative of continuous texture coordinate\r\n\t\t\t// to avoid mipmapping artifacts caused by manual wrapping in shader\r\n\t\t\tvec2 dUVdx \x3d dFdx(vtc) * atlasScale;\r\n\t\t\tvec2 dUVdy \x3d dFdy(vtc) * atlasScale;\r\n\r\n\t\t\t#ifdef GL_EXT_shader_texture_lod\r\n\t\t\t\t#extension GL_EXT_shader_texture_lod : enable\r\n\r\n\t\t\t\t// workaround for artifacts in Windows 10 using Intel HD Graphics 4000 series\r\n\t\t\t\t// see: https://devtopia.esri.com/Zurich-R-D-Center/arcgis-js-api-canvas3d-issues/issues/768\r\n\t\t\t\tconst float epsilon \x3d 1.0E-32;\r\n\t\t\t\tfloat zeroUVShift \x3d uv.x \x3d\x3d 0.0 \x26\x26 uv.y \x3d\x3d 0.0 ? epsilon : 0.0;\r\n\r\n\t\t\t\ttexColor \x3d texture2DGradEXT(tex, uv + zeroUVShift, dUVdx, dUVdy);\r\n\t\t\t#else\r\n\t\t\t\t// use bias to compensate for difference in automatic vs desired mipmap level\r\n\t\t\t\tvec2 dUVdxAuto \x3d dFdx(uv);\r\n\t\t\t\tvec2 dUVdyAuto \x3d dFdy(uv);\r\n\t\t\t\tfloat mipMapLevel \x3d calcMipMapLevel(dUVdx * texSize, dUVdy * texSize);\r\n\t\t\t\tfloat autoMipMapLevel \x3d calcMipMapLevel(dUVdxAuto * texSize, dUVdyAuto * texSize);\r\n\t\t\t\ttexColor \x3d texture2D(tex, uv, mipMapLevel - autoMipMapLevel);\r\n\t\t\t#endif\r\n\t\t#else\r\n\t\t\ttexColor \x3d texture2D(tex, uv);\r\n\t\t#endif\r\n\r\n\t\tif (texColor.a \x3c .33) discard;\r\n\r\n\t\t$externalColorMix\r\n\r\n\t\tvec3 shadedColor \x3d evaluateSceneLighting(normal, albedo_, shadow, 1.0 - ssao, additionalLight);\r\n\t\tgl_FragColor \x3d vec4(shadedColor, opacity_);\r\n\t}\r\n\t]]\x3e\x3c/snippet\x3e\r\n\r\n\t\x3csnippet name\x3d"fsPhongTexturedRefl"\x3e\x3c![CDATA[\r\n\t\t$fsprecisionf\r\n\r\n\t\tuniform sampler2D tex;\r\n\t\tuniform sampler2D reflTex;\r\n\t\tuniform float reflectivity;\r\n\t\tvarying vec2 vtc;\r\n\r\n\t\t$normal2envTC\r\n\r\n\t\t$fsPhongSrc\r\n\t\tvec4 texColor \x3d texture2D(tex, vtc);\r\n\t\tif (texColor.a \x3c .33) discard;\r\n\t\tvec4 reflColor \x3d texture2D(reflTex, normal2envTC(reflDir));\r\n\r\n\t\t$externalColorMix\r\n\r\n\t\tvec3 shadedColor \x3d evaluateSceneLighting(normal, albedo_, shadow, 1.0 - ssao, additionalLight);\r\n\t\tshadedColor.rgb \x3d mix(shadedColor.rgb, reflColor.rgb, reflectivity);\r\n\r\n\t\tgl_FragColor \x3d vec4(shadedColor, opacity_);\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsDepthSrc"\x3e\x3c![CDATA[\r\n\tuniform mat4 proj;\r\n\tuniform mat4 view;\r\n  uniform vec3 camPos;\r\n  uniform vec3 localOrigin;\r\n\r\n#ifdef INSTANCED\r\n\tattribute mat4 model;\r\n  attribute mat4 modelNormal;\r\n#else\r\n\tuniform mat4 model;\r\n  uniform mat4 modelNormal;\r\n#endif\r\n\tuniform vec2 nearFar;\r\n\tattribute vec3 $position;\r\n\tvarying float depth;\r\n\r\n\t$vvUniforms\r\n#if defined(VV_CUSTOM_MODEL_MATRIX)\r\n\tattribute vec4 instanceFeatureAttribute;\r\n#endif\r\n\t$vvFunctions\r\n\r\n  $calculateVerticalOffset\r\n\r\n\tvoid main(void) {\r\n\r\n#ifdef VV_CUSTOM_MODEL_MATRIX\r\n\r\n    vec3 vpos \x3d (model * vvTransformPosition($position, instanceFeatureAttribute)).xyz;\r\n\r\n#ifdef VERTICAL_OFFSET\r\n    vec3 centerPos \x3d (model * vvTransformPosition(vec3(0, 0, 0), instanceFeatureAttribute)).xyz;\r\n#endif\r\n\r\n#else /* VV_CUSTOM_MODEL_MATRIX */\r\n\r\n\t\tvec3 vpos \x3d (model * vec4($position, 1.0)).xyz;\r\n\r\n#ifdef VERTICAL_OFFSET\r\n\t\tvec3 centerPos \x3d (model * vec4(vec3(0, 0, 0), 1.0)).xyz;\r\n#endif\r\n\r\n#endif /* VV_CUSTOM_MODEL_MATRIX */\r\n\r\n#ifdef VERTICAL_OFFSET\r\n    vpos +\x3d calculateVerticalOffset(centerPos, localOrigin);\r\n#endif\r\n\r\n    vec4 eye \x3d view * vec4(vpos, 1);\r\n\r\n\t\tgl_Position \x3d proj * eye;\r\n\t\tdepth \x3d (-eye.z - nearFar[0]) / (nearFar[1] - nearFar[0]) ;\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsDepth"\x3e\x3c![CDATA[\r\n  $vsprecisionf\r\n\r\n\t$vsDepthSrc\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsDepthTextured"\x3e\x3c![CDATA[\r\n  $vsprecisionf\r\n\r\n\tattribute vec2 $uv0;\r\n\tvarying vec2 vtc;\r\n\t$vsDepthSrc\r\n#ifndef FLIPV\r\n        vtc \x3d $uv0;\r\n#else\r\n        vtc \x3d vec2($uv0.x, 1.0-$uv0.y);\r\n#endif\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsNormalSrc"\x3e\x3c![CDATA[\r\n\tuniform mat4 proj;\r\n\tuniform mat4 view;\r\n  uniform vec3 camPos;\r\n  uniform vec3 localOrigin;\r\n\r\n#ifdef INSTANCED\r\n\tattribute mat4 model;\r\n\tattribute mat4 modelNormal;\r\n#else\r\n\tuniform mat4 model;\r\n\tuniform mat4 modelNormal;\r\n#endif\r\n\tuniform mat4 viewNormal;\r\n\tattribute vec3 $position;\r\n\tattribute vec3 $normal;\r\n\tvarying vec3 vnormal;\r\n\r\n\t$vvUniforms\r\n#if defined(VV_CUSTOM_MODEL_MATRIX)\r\n\tattribute vec4 instanceFeatureAttribute;\r\n#endif\r\n\t$vvFunctions\r\n\r\n  $calculateVerticalOffset\r\n\r\n\tvoid main(void) {\r\n\r\n#ifdef VV_CUSTOM_MODEL_MATRIX\r\n\r\n    vec3 vpos \x3d (model * vvTransformPosition($position, instanceFeatureAttribute)).xyz;\r\n\t\tvnormal \x3d normalize((viewNormal * modelNormal * vvTransformNormal($normal, instanceFeatureAttribute)).xyz);\r\n\r\n#ifdef VERTICAL_OFFSET\r\n    vec3 centerPos \x3d (model * vvTransformPosition(vec3(0, 0, 0), instanceFeatureAttribute)).xyz;\r\n#endif\r\n\r\n#else /* VV_CUSTOM_MODEL_MATRIX */\r\n\t\tvec3 vpos \x3d (model * vec4($position, 1.0)).xyz;\r\n\t\tvnormal \x3d normalize((viewNormal * modelNormal * vec4($normal, 1.0)).xyz);\r\n\r\n#ifdef VERTICAL_OFFSET\r\n    vec3 centerPos \x3d (model * vec4(vec3(0, 0, 0), 1.0)).xyz;\r\n#endif\r\n\r\n#endif /* VV_CUSTOM_MODEL_MATRIX */\r\n\r\n#ifdef VERTICAL_OFFSET\r\n    vpos +\x3d calculateVerticalOffset(centerPos, localOrigin);\r\n#endif\r\n\r\n    gl_Position \x3d proj * view * vec4(vpos, 1);\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsNormal"\x3e\x3c![CDATA[\r\n  $vsprecisionf\r\n\r\n\t$vsNormalSrc\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsNormalTextured"\x3e\x3c![CDATA[\r\n  $vsprecisionf\r\n\r\n\tattribute vec2 $uv0;\r\n\tvarying vec2 vtc;\r\n\t$vsNormalSrc\r\n#ifndef FLIPV\r\n\t\tvtc \x3d $uv0;\r\n#else\r\n\t\tvtc \x3d vec2($uv0.x, 1.0-$uv0.y);\r\n#endif\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsHighlightSrc"\x3e\x3c![CDATA[\r\n  $vsprecisionf\r\n\r\n\tuniform mat4 proj;\r\n\tuniform mat4 view;\r\n  uniform vec3 camPos;\r\n  uniform vec3 localOrigin;\r\n\r\n#ifdef INSTANCED\r\n\tattribute mat4 model;\r\n  attribute mat4 modelNormal;\r\n#else\r\n\tuniform mat4 model;\r\n  uniform mat4 modelNormal;\r\n#endif\r\n\tattribute vec3 $position;\r\n\r\n\t$vvUniforms\r\n#if defined(VV_CUSTOM_MODEL_MATRIX)\r\n\tattribute vec4 instanceFeatureAttribute;\r\n#endif\r\n\t$vvFunctions\r\n\r\n  $calculateVerticalOffset\r\n\r\n\tvoid main(void) {\r\n\r\n#ifdef VV_CUSTOM_MODEL_MATRIX\r\n\r\n    vec3 vpos \x3d (model * vvTransformPosition($position, instanceFeatureAttribute)).xyz;\r\n\r\n#ifdef VERTICAL_OFFSET\r\n    vec3 centerPos \x3d (model * vvTransformPosition(vec3(0, 0, 0), instanceFeatureAttribute)).xyz;\r\n#endif\r\n\r\n#else /* VV_CUSTOM_MODEL_MATRIX */\r\n\r\n    vec3 vpos \x3d (model * vec4($position, 1.0)).xyz;\r\n\r\n#ifdef VERTICAL_OFFSET\r\n    vec3 centerPos \x3d (model * vec4(vec3(0, 0, 0), 1.0)).xyz;\r\n#endif\r\n\r\n#endif /* VV_CUSTOM_MODEL_MATRIX */\r\n\r\n#ifdef VERTICAL_OFFSET\r\n    vpos +\x3d calculateVerticalOffset(centerPos, localOrigin);\r\n#endif\r\n\r\n\t\tgl_Position \x3d proj * view * vec4(vpos, 1);\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsHighlight"\x3e\x3c![CDATA[\r\n\t$vsHighlightSrc\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vsHighlightTextured"\x3e\x3c![CDATA[\r\n  $vsprecisionf\r\n\r\n\tattribute vec2 $uv0;\r\n\tvarying vec2 vtc;\r\n\t$vsHighlightSrc\r\n#ifndef FLIPV\r\n\t\tvtc \x3d $uv0;\r\n#else\r\n\t\tvtc \x3d vec2($uv0.x, 1.0-$uv0.y);\r\n#endif\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsDepthSrc"\x3e\x3c![CDATA[\r\n  $fsprecisionf\r\n\tvarying float depth;\r\n\r\n\tvoid main() {\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsDepth"\x3e\x3c![CDATA[\r\n\t$fsprecisionf\r\n\r\n\t$calcFragDepth\r\n\t$float2rgba\r\n\t$fsDepthSrc\r\n#ifndef BIAS_SHADOWMAP\r\n\t\tgl_FragColor \x3d float2rgba(depth);\r\n#else\r\n\t\tgl_FragColor \x3d float2rgba(calcFragDepth(depth));\r\n#endif\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsDepthTextured"\x3e\x3c![CDATA[\r\n\t$fsprecisionf\r\n\r\n\tuniform sampler2D tex;\r\n\tvarying vec2 vtc;\r\n\t$calcFragDepth\r\n\t$float2rgba\r\n\r\n\t$fsDepthSrc\r\n\t\tif (texture2D(tex, vtc).a \x3c .33) discard;\r\n#ifndef BIAS_SHADOWMAP\r\n\t\tgl_FragColor \x3d float2rgba(depth);\r\n#else\r\n\t\tgl_FragColor \x3d float2rgba(calcFragDepth(depth));\r\n#endif\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsNormal"\x3e\x3c![CDATA[\r\n\t$fsprecisionf\r\n\r\n\tvarying vec3 vnormal;\r\n\tvoid main() {\r\n\t\tvec3 normal \x3d normalize(vnormal);\r\n\t\tif (gl_FrontFacing \x3d\x3d false) normal \x3d -normal;\r\n\r\n#ifndef ALPHA_ZERO\r\n\t\tgl_FragColor \x3d vec4(vec3(.5) + .5 * normal, 1.0);\r\n#else\r\n\t\tgl_FragColor \x3d vec4(vec3(.5) + .5 * normal, 0.0);\r\n#endif\r\n\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsNormalTextured"\x3e\x3c![CDATA[\r\n\t$fsprecisionf\r\n\r\n\tvarying vec3 vnormal;\r\n\tvarying vec2 vtc;\r\n\tuniform sampler2D tex;\r\n\tvoid main() {\r\n\t\tif (texture2D(tex, vtc).a \x3c .33) discard;\r\n\t\tvec3 normal \x3d normalize(vnormal);\r\n\t\tif (gl_FrontFacing \x3d\x3d false) normal \x3d -normal;\r\n#ifndef ALPHA_ZERO\r\n\t\tgl_FragColor \x3d vec4(vec3(.5) + .5 * normal, 1.0);\r\n#else\r\n\t\tgl_FragColor \x3d vec4(vec3(.5) + .5 * normal, 0.0);\r\n#endif\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsHighlight"\x3e\x3c![CDATA[\r\n\t$fsprecisionf\r\n  uniform sampler2D depthTex;\r\n  uniform vec4 highlightViewportPixelSz;\r\n\r\n\tvoid main() {\r\n\t\t$highlightWrite\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fsHighlightTextured"\x3e\x3c![CDATA[\r\n\t$fsprecisionf\r\n\r\n\tvarying vec2 vtc;\r\n\tuniform sampler2D tex;\r\n  uniform sampler2D depthTex;\r\n  uniform vec4 highlightViewportPixelSz;\r\n\r\n\tvoid main() {\r\n\t\tif (texture2D(tex, vtc).a \x3c .33) discard;\r\n\r\n\t\t$highlightWrite\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3c/snippets\x3e\r\n'}});
define("dojo/text!./Material.xml ./internal/MaterialUtil ../../../webgl/Program ../lib/ShaderVariations ../lib/Util ../lib/gl-matrix ../lib/RenderSlot ../lib/DefaultVertexAttributeLocations ../lib/DefaultVertexBufferLayouts ../../../webgl/Util ../../layers/graphics/graphicUtils".split(" "),function(Q,f,n,y,R,z,E,t,S,u,T){function A(a,d){var h=d.vvSizeEnabled;d.vvSizeEnabled?(a.setUniform3fv("vvSizeMinSize",d.vvSizeMinSize),a.setUniform3fv("vvSizeMaxSize",d.vvSizeMaxSize),a.setUniform3fv("vvSizeOffset",
d.vvSizeOffset),a.setUniform3fv("vvSizeFactor",d.vvSizeFactor)):h&&a.setUniform3fv("vvSizeValue",d.vvSizeValue);h&&(a.setUniform3fv("vvSymbolAnchor",d.vvSymbolAnchor),T.computeObjectRotation(d.vvSymbolRotation[2],d.vvSymbolRotation[0],d.vvSymbolRotation[1],F.identity(K)),a.setUniformMatrix3fv("vvSymbolRotation",F.toMat3(K,U)));d.vvColorEnabled&&(a.setUniform1fv("vvColorValues",d.vvColorValues),a.setUniform4fv("vvColorColors",d.vvColorColors))}function B(a,d){a.vvSizeEnabled=d.vvSizeEnabled;a.vvSizeMinSize=
d.vvSizeMinSize;a.vvSizeMaxSize=d.vvSizeMaxSize;a.vvSizeOffset=d.vvSizeOffset;a.vvSizeFactor=d.vvSizeFactor;a.vvSizeValue=d.vvSizeValue;a.vvSymbolAnchor=d.vvSymbolAnchor;a.vvSymbolRotation=d.vvSymbolRotation}function V(a,d){G.set(a,L);return G.multiply(d,L)}var H=R.assert,e=z.vec3,G=z.vec4,M=z.mat3,F=z.mat4,v,L=G.create(),U=M.create(),K=F.create(),W=e.create(),X=e.create(),Y=e.createFrom(0,0,1),N=e.create(),I=e.create(),J=e.create(),Z=e.create(),w=function(a,d){f.basicMaterialConstructor(this,d);
a=a||{};a.ambient=a.ambient||[.2,.2,.2];a.diffuse=a.diffuse||[.8,.8,.8];a.specular=a.specular||[0,0,0];a.externalColor=a.externalColor||[1,1,1,1];a.colorMixMode=a.colorMixMode||"multiply";a.shininess=a.shininess||10;a.opacity=void 0!==a.opacity?a.opacity:1;a.layerOpacity=void 0!==a.layerOpacity?a.layerOpacity:1;a.blendModeOneOne=a.blendModeOneOne||!1;a.inverseWindingOrder=a.inverseWindingOrder||!1;a.vertexColors=a.vertexColors||!1;a.symbolColors=a.symbolColors||!1;a.flipV=a.flipV||!1;a.doubleSided=
a.doubleSided||!1;a.cullFace=a.cullFace||void 0;a.instanced=a.instanced||!1;this.instanced=!!a.instanced;a.groundNormalShading=a.groundNormalShading||!1;a.writeStencil=a.writeStencil||!1;a.textureId||(a.reflTextureId=void 0);a.receiveSSAO=void 0!==a.receiveSSAO?a.receiveSSAO:!0;a.castShadows=void 0!==a.castShadows?a.castShadows:!0;a.verticalOffset=a.verticalOffset||null;a.screenSizePerspective=a.screenSizePerspective||null;a.vvSizeEnabled=a.vvSizeEnabled||!1;a.vvSizeMinSize=a.vvSizeMinSize||[1,1,
1];a.vvSizeMaxSize=a.vvSizeMaxSize||[100,100,100];a.vvSizeOffset=a.vvSizeOffset||[0,0,0];a.vvSizeFactor=a.vvSizeFactor||[1,1,1];a.vvSizeValue=a.vvSizeValue||[1,1,1];a.vvColorEnabled=a.vvColorEnabled||!1;a.vvColorValues=a.vvColorValues||[0,0,0,0,0,0,0,0];a.vvColorColors=a.vvColorColors||[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0];a.vvSymbolAnchor=a.vvSymbolAnchor||[0,0,0];a.vvSymbolRotation=a.vvSymbolRotation||[0,0,0];var h=w.getVertexBufferLayout(a),b=null;a.instanced&&(b=[],
u.addDescriptor(b,"model",16,5126,!1,1),u.addDescriptor(b,"modelNormal",16,5126,!1,1),-1<a.instanced.indexOf("color")&&u.addDescriptor(b,"instanceColor",4,5126,!1,1),-1<a.instanced.indexOf("featureAttribute")&&u.addDescriptor(b,"instanceFeatureAttribute",4,5126,!1,1));var c=this.isVisible.bind(this);this.isVisible=function(){return c()&&0<a.opacity&&0<a.layerOpacity};this.dispose=function(){};this.getParams=function(){return a};this.getParameterValues=function(){var b={ambient:a.ambient,diffuse:a.diffuse,
specular:a.specular,externalColor:a.externalColor,colorMixMode:a.colorMixMode,shininess:a.shininess,opacity:a.opacity,layerOpacity:a.layerOpacity,transparent:a.transparent,polygonOffset:a.polygonOffset,reflectivity:a.reflectivity,atlasRegions:a.atlasRegions,flipV:a.flipV,doubleSided:a.doubleSided,cullFace:a.cullFace,writeStencil:a.writeStencil,receiveSSAO:a.receiveSSAO,castShadows:a.castShadows,verticalOffset:a.verticalOffset,screenSizePerspective:a.screenSizePerspective,vvSizeEnabled:a.vvSizeEnabled,
vvSizeMinSize:a.vvSizeMinSize,vvSizeMaxSize:a.vvSizeMaxSize,vvSizeOffset:a.vvSizeOffset,vvSizeFactor:a.vvSizeFactor,vvSizeValue:a.vvSizeValue,vvColorEnabled:a.vvColorEnabled,vvColorValues:a.vvColorValues,vvColorColors:a.vvColorColors,groundNormalShading:a.groundNormalShading,vvSymbolAnchor:a.vvSymbolAnchor,vvSymbolRotation:a.vvSymbolRotation};a.textureId&&(b.textureId=a.textureId,b.initTexture=a.initTexture);return b};this.setParameterValues=function(b){for(var c in b)"textureId"===c&&H(a.textureId,
"Can only change texture of material that already has a texture"),"castShadows"===c&&H(b.castShadows===a.castShadows,"Can not change shadow casting behavior."),a[c]=b[c];this.notifyDirty("matChanged")};this.getOutputAmount=function(a){var b=u.getStride(h)/4;return a*b};this.getVertexBufferLayout=function(){return h};this.getInstanceBufferLayout=function(){return b};this.fillInterleaved=function(a,b,c,d,k,e,g){f.fillInterleaved(a,b,c,d,h,k,e,g)};this.intersect=function(b,c,d,p,h,q,g,r){if(null!=a.verticalOffset){r=
p.camera;e.set3(d[12],d[13],d[14],J);var m=e.subtract(J,r.eye,Z),O=e.length(m),l=e.scale(m,1/O),k=null,m=null;switch(p.viewingMode){case "global":m=e.normalize(J,N);break;case "local":m=e.set(Y,N)}a.screenSizePerspective&&(k=e.dot(m,l));r=f.verticalOffsetAtDistance(r,O,a.verticalOffset,k,a.screenSizePerspective);e.scale(m,r);M.multiplyVec3(p.transformInverseRotation,m,I);h=e.subtract(h,I,W);q=e.subtract(q,I,X)}f.intersectTriangleGeometry(b,c,d,p,h,q,g)};this.getGLMaterials=function(){return{color:aa,
depthShadowMap:a.castShadows?ba:null,normal:ca,depth:P,highlight:da}};this.getAllTextureIds=function(){var b=[];a.textureId&&b.push(a.textureId);a.reflTextureId&&b.push(a.reflTextureId);return b}};w.paramsFromOldConstructor=function(a,d,h,b,c,l,f,m,p,k,e,g,r){return{textureId:a,transparent:d,ambient:h,diffuse:b,specular:c,shininess:l,opacity:f,polygonOffset:m,initTexture:p,reflTextureId:k,reflectivity:e,flipV:g,doubleSided:r,cullFace:void 0}};var C=function(a,d){var h=a.gl;(d.cullFace?"none"===d.cullFace:
d.transparent)?a.setFaceCullingEnabled(!1):(a.setFaceCullingEnabled(!0),"front"===d.cullFace&&a.setCullFace(h.FRONT))},D=function(a,d){var h=a.gl;(d.cullFace?"none"===d.cullFace:d.transparent)?a.setFaceCullingEnabled(!0):(a.setFaceCullingEnabled(!1),"front"===d.cullFace&&a.setCullFace(h.BACK))},x=function(a,d){return a?E.TRANSPARENT_MATERIAL:d?E.STENCIL_MATERIAL:E.OPAQUE_MATERIAL},aa=function(a,d,h){f.basicGLMaterialConstructor(this,a);var b=f.copyParameters(a.getParams()),c=x(b.transparent,b.writeStencil);
f.singleTextureGLMaterialConstructor(this,h,b);var l=f.aquireIfNotUndefined(b.reflTextureId,b.reflInitTexture,h);l&&(l=l.getGLTexture());H(!(b.atlasRegions&&b.reflTextureId),"Atlas texture with reflection is not yet supported");var e=b.textureId?b.atlasRegions?"AtlasTextured":"Textured":"none";this.instanced=v&&b.instanced;var m=!!this.instanced&&-1<this.instanced.indexOf("color"),p=!v&&b.instanced&&-1<b.instanced.indexOf("color"),k=[[null,null],[null,null]],q,g=null;this._loadPrograms=function(){k[0][0]=
this._loadProgram(!1,!1);k[1][0]=this._loadProgram(!0,!1);b.receiveSSAO?(k[0][1]=this._loadProgram(!1,!0),k[1][1]=this._loadProgram(!0,!0),q=k[0].concat(k[1])):(k[0][1]=k[0][0],k[1][1]=k[1][0],q=[k[0][0],k[1][0]])};this._loadProgram=function(a,c){return d.getShaderVariationsProgram("material",[e,!!b.reflTextureId,b.vertexColors,b.symbolColors,b.flipV,b.doubleSided,!!this.instanced,m,a,c,!!b.vvSizeEnabled,!!b.vvColorEnabled,null!=b.verticalOffset,null!=b.screenSizePerspective,b.groundNormalShading])};
this._loadPrograms();var r="AtlasTextured"===e,n=this.dispose;this.dispose=function(){n();f.releaseIfNotUndefined(b.reflTextureId,h)};this.beginSlot=function(a){return c===a};this.getProgram=function(){return g||k[0][0]};this.getAllPrograms=function(){return q};this.updateParameters=function(){var d=a.getParams();b.ambient=d.ambient;b.diffuse=d.diffuse;b.specular=d.specular;b.externalColor=d.externalColor;b.colorMixMode=d.colorMixMode;b.shininess=d.shininess;b.opacity=d.opacity;b.layerOpacity=d.layerOpacity;
b.polygonOffset=d.polygonOffset;b.reflectivity=d.reflectivity;b.flipV=d.flipV;b.doubleSided=d.doubleSided;b.cullFace=d.cullFace;b.receiveSSAO=d.receiveSSAO;b.castShadows=d.castShadows;b.verticalOffset=d.verticalOffset;b.screenSizePerspective=d.screenSizePerspective;B(b,d);b.vvColorEnabled=d.vvColorEnabled;b.vvColorValues=d.vvColorValues;b.vvColorColors=d.vvColorColors;b.transparent!=d.transparent&&(c=x(d.transparent),b.transparent=d.transparent);b.groundNormalShading=d.groundNormalShading;b.initTexture=
d.initTexture;this.updateTexture(d.textureId);d.atlasRegions&&(b.atlasRegions=d.atlasRegions);b.blendModeOneOne=d.blendModeOneOne;b.inverseWindingOrder=d.inverseWindingOrder;this._loadPrograms()};this.bind=function(a,d){var c=a.gl;g=k[d.shadowMappingEnabled?1:0][d.ssaoEnabled?1:0];a.bindProgram(g);g.setUniform3fv("ambient",b.ambient);g.setUniform3fv("diffuse",b.diffuse);g.setUniform3fv("specular",b.specular);g.setUniform4fv("externalColor",b.externalColor);g.setUniform1i("colorMixMode",f.colorMixModes[b.colorMixMode]);
g.setUniform1f("shininess",b.shininess);g.setUniform1f("opacity",b.opacity);g.setUniform1f("layerOpacity",b.layerOpacity);f.bindVerticalOffset(b.verticalOffset,d,g);f.bindScreenSizePerspective(b.screenSizePerspective,g);A(g,b);this.bindTexture(a,g);r&&this.bindTextureSize(a,g);a.setBlendFunctionSeparate(c.SRC_ALPHA,c.ONE_MINUS_SRC_ALPHA,c.ONE,c.ONE_MINUS_SRC_ALPHA);void 0!==l&&(g.setUniform1i("reflTex",1),a.bindTexture(l,1),g.setUniform1f("reflectivity",b.reflectivity));b.inverseWindingOrder&&a.setFrontFace(c.CW);
b.transparent?(a.setBlendingEnabled(!0),b.blendModeOneOne?(a.setBlendFunction(c.ONE,c.ONE),a.setDepthWriteEnabled(!1)):a.setBlendFunctionSeparate(c.SRC_ALPHA,c.ONE_MINUS_SRC_ALPHA,c.ONE,c.ONE_MINUS_SRC_ALPHA)):a.setBlendingEnabled(!1);b.polygonOffset&&(a.setPolygonOffsetFillEnabled(!0),a.setPolygonOffset(2,2));C(a,b);a.setDepthTestEnabled(!0)};this.release=function(a,c){c=a.gl;a.setPolygonOffsetFillEnabled(!1);D(a,b);a.setBlendingEnabled(!1);a.setBlendFunctionSeparate(c.SRC_ALPHA,c.ONE_MINUS_SRC_ALPHA,
c.ONE,c.ONE_MINUS_SRC_ALPHA);a.setDepthWriteEnabled(!0);a.setFrontFace(c.CCW)};this.bindView=function(a,b){g=k[b.shadowMappingEnabled?1:0][b.ssaoEnabled?1:0];a=b.origin;f.bindView(a,b.view,g);f.bindCamPos(a,b.viewInvTransp,g);b.shadowMappingEnabled&&b.shadowMap.bindView(g,a)};this.bindInstance=function(a,c){g.setUniformMatrix4fv("model",c.transformation);g.setUniformMatrix4fv("modelNormal",c.transformationNormal);c.instanceParameters&&p&&(a=c.instanceParameters.color)&&g.setUniform4fv("externalColor",
V(a,b.externalColor))};this.getDrawMode=function(a){return a.gl.TRIANGLES}},P=function(a,d,h,b){f.basicGLMaterialConstructor(this,a);var c=f.copyParameters(a.getParams());this.instanced=v&&c.instanced;var l=u.hasAttribute(a.getVertexBufferLayout(),"uv0")?"Textured":"none",e=d.getShaderVariationsProgram("material-depth",[l,c.flipV,!!this.instanced,!!b,!!c.vvSizeEnabled,null!=c.verticalOffset,null!=c.screenSizePerspective]),m=x(c.transparent,c.writeStencil);f.singleTextureGLMaterialConstructor(this,
h,c);this.beginSlot=function(a){return m===a};this.getProgram=function(){return e};this.updateParameters=function(){var b=a.getParams();c.initTexture=b.initTexture;c.cullFace=b.cullFace;c.inverseWindingOrder=b.inverseWindingOrder;c.flipV=b.flipV;B(c,b);this.updateTexture(b.textureId)};this.bind=function(a,b){var d=a.gl;a.bindProgram(e);e.setUniform2fv("nearFar",b.nearFar);c.inverseWindingOrder&&a.setFrontFace(d.CW);f.bindVerticalOffset(c.verticalOffset,b,e);f.bindScreenSizePerspective(c.screenSizePerspective,
e);A(e,c);this.bindTexture(a,e);C(a,c);a.setDepthTestEnabled(!0)};this.release=function(a){var b=a.gl;D(a,c);c.inverseWindingOrder&&a.setFrontFace(b.CCW)};this.bindView=function(a,b){f.bindView(b.origin,b.view,e);c.screenSizePerspective&&f.bindCamPos(b.origin,b.viewInvTransp,e)};this.bindInstance=function(a,b){e.setUniformMatrix4fv("model",b.transformation)};this.getDrawMode=function(a){return a.gl.TRIANGLES}},ba=function(a,d,h){P.call(this,a,d,h,!0)},ca=function(a,d,h){f.basicGLMaterialConstructor(this,
a);var b=f.copyParameters(a.getParams()),c=u.hasAttribute(a.getVertexBufferLayout(),"uv0")?"Textured":"none";this.instanced=v&&b.instanced;var l=d.getShaderVariationsProgram("material-normal",[c,b.flipV,!!this.instanced,!!b.vvSizeEnabled,null!=b.verticalOffset,null!=b.screenSizePerspective]),e=x(b.transparent,b.writeStencil);f.singleTextureGLMaterialConstructor(this,h,b);this.beginSlot=function(a){return e===a};this.getProgram=function(){return l};this.updateParameters=function(){var c=a.getParams();
b.initTexture=c.initTexture;b.cullFace=c.cullFace;b.inverseWindingOrder=c.inverseWindingOrder;b.flipV=c.flipV;B(b,c);this.updateTexture(c.textureId)};this.bind=function(a,c){var d=a.gl;a.bindProgram(l);this.bindTexture(a,l);l.setUniformMatrix4fv("viewNormal",c.viewInvTransp);f.bindVerticalOffset(b.verticalOffset,c,l);f.bindScreenSizePerspective(b.screenSizePerspective,l);A(l,b);C(a,b);b.inverseWindingOrder&&a.setFrontFace(d.CW);a.setDepthTestEnabled(!0)};this.release=function(a){var c=a.gl;D(a,b);
b.inverseWindingOrder&&a.setFrontFace(c.CCW)};this.bindView=function(a,c){f.bindView(c.origin,c.view,l);b.screenSizePerspective&&f.bindCamPos(c.origin,c.viewInvTransp,l)};this.bindInstance=function(a,b){l.setUniformMatrix4fv("model",b.transformation);l.setUniformMatrix4fv("modelNormal",b.transformationNormal)};this.getDrawMode=function(a){return a.gl.TRIANGLES}},da=function(a,d,h,b){f.basicGLMaterialConstructor(this,a);var c=f.copyParameters(a.getParams());b=u.hasAttribute(a.getVertexBufferLayout(),
"uv0")?"Textured":"none";this.instanced=v&&c.instanced;var e=d.getShaderVariationsProgram("material-highlight",[b,c.flipV,!!this.instanced,!!c.vvSizeEnabled,null!=c.verticalOffset,null!=c.screenSizePerspective]),n=x(c.transparent,c.writeStencil);f.singleTextureGLMaterialConstructor(this,h,c);this.beginSlot=function(a){return n===a};this.getProgram=function(){return e};this.updateParameters=function(){var b=a.getParams();c.initTexture=b.initTexture;c.cullFace=b.cullFace;c.inverseWindingOrder=b.inverseWindingOrder;
c.flipV=b.flipV;B(c,b);this.updateTexture(b.textureId)};this.bind=function(a,b){var d=a.gl;a.bindProgram(e);this.bindTexture(a,e);f.bindVerticalOffset(c.verticalOffset,b,e);f.bindScreenSizePerspective(c.screenSizePerspective,e);A(e,c);C(a,c);c.inverseWindingOrder&&a.setFrontFace(d.CW);a.setDepthTestEnabled(!0)};this.release=function(a){var b=a.gl;D(a,c);c.inverseWindingOrder&&a.setFrontFace(b.CW)};this.bindView=function(a,b){f.bindView(b.origin,b.view,e);c.screenSizePerspective&&f.bindCamPos(b.origin,
b.viewInvTransp,e)};this.bindInstance=function(a,b){e.setUniformMatrix4fv("model",b.transformation);e.setUniformMatrix4fv("modelNormal",b.transformationNormal)};this.getDrawMode=function(a){return a.gl.TRIANGLES}};w.getVertexBufferLayout=function(a){var d="Pos3";a.groundNormalShading||(d+="Norm");a.textureId&&(d=a.atlasRegions?d+"TexRegion":d+"Tex");a.vertexColors&&(d+="Col");a.symbolColors&&(d+="Symcol");return S[d]};w.loadShaders=function(a,d,e,b){a._parse(Q);v=b.extensions.angleInstancedArrays;
b.extensions.shaderTextureLOD;b.extensions.standardDerivatives;var c=new y("phong",["vsPhong","fsPhong"],null,e,d,a,b);c.addNaryShaderSnippetSuffix([{value:"none",programNameSuffix:"",shaderSnippetSuffix:""},{value:"Textured"},{value:"AtlasTextured"}]);c.addBinaryShaderSnippetSuffix("Refl","Refl",[!1,!0]);c.addDefine("Color","VERTEXCOLORS");c.addDefine("symbolColor","SYMBOLVERTEXCOLORS");c.addDefine("FlipV","FLIPV");c.addDefine("DoubleSided","DOUBLESIDED");c.addDefine("Instanced","INSTANCED");c.addDefine("InstColor",
"INSTANCEDCOLOR");c.addDefine("ReceiveShadows","RECEIVE_SHADOWS");c.addDefine("ReceiveSSAO","RECEIVE_SSAO");c.addDefine("vvSize","VV_SIZE");c.addDefine("vvColor","VV_COLOR");c.addDefine("VerticalOffset","VERTICAL_OFFSET");c.addDefine("screenSizePerspective","SCREEN_SIZE_PERSPECTIVE");c.addDefine("groundNormalShading","GROUND_NORMAL_SHADING");e.addShaderVariations("material",c);c=new y("depth",["vsDepth","fsDepth"],null,e,d,a,b);c.addNaryShaderSnippetSuffix([{value:"none",programNameSuffix:"",shaderSnippetSuffix:""},
{value:"Textured"},{value:"AtlasTextured"}]);c.addDefine("FlipV","FLIPV");c.addDefine("Instanced","INSTANCED");c.addDefine("ShadowMap","BIAS_SHADOWMAP");c.addDefine("vvSize","VV_SIZE");c.addDefine("VerticalOffset","VERTICAL_OFFSET");c.addDefine("screenSizePerspective","SCREEN_SIZE_PERSPECTIVE");e.addShaderVariations("material-depth",c);c=new y("normal",["vsNormal","fsNormal"],null,e,d,a,b);c.addNaryShaderSnippetSuffix([{value:"none",programNameSuffix:"",shaderSnippetSuffix:""},{value:"Textured"},
{value:"AtlasTextured"}]);c.addDefine("FlipV","FLIPV");c.addDefine("Instanced","INSTANCED");c.addDefine("vvSize","VV_SIZE");c.addDefine("VerticalOffset","VERTICAL_OFFSET");c.addDefine("screenSizePerspective","SCREEN_SIZE_PERSPECTIVE");e.addShaderVariations("material-normal",c);c=new y("highlight",["vsHighlight","fsHighlight"],null,e,d,a,b);c.addNaryShaderSnippetSuffix([{value:"none",programNameSuffix:"",shaderSnippetSuffix:""},{value:"Textured"},{value:"AtlasTextured"}]);c.addDefine("FlipV","FLIPV");
c.addDefine("Instanced","INSTANCED");c.addDefine("vvSize","VV_SIZE");c.addDefine("VerticalOffset","VERTICAL_OFFSET");c.addDefine("screenSizePerspective","SCREEN_SIZE_PERSPECTIVE");e.addShaderVariations("material-highlight",c);var c=new n(b,a.vsDepth,a.fsDepth,t.Default3D,["BIAS_SHADOWMAP 1"]),f=new n(b,a.vsDepthTextured,a.fsDepthTextured,t.Default3D,["BIAS_SHADOWMAP 1"]),h=new n(b,a.vsDepth,a.fsDepth,t.Default3D),m=new n(b,a.vsDepthTextured,a.fsDepthTextured,t.Default3D),p=new n(b,a.vsNormal,a.fsNormal,
t.Default3D),k=new n(b,a.vsNormalTextured,a.fsNormalTextured,t.Default3D),q=new n(b,a.vsHighlight,a.fsHighlight,t.Default3D);b=new n(b,a.vsHighlightTextured,a.fsHighlightTextured,t.Default3D);e.add("depthShadowMap",c);e.add("depthTexturedShadowMap",f);e.add("depth",h);e.add("depthTextured",m);e.add("normal",p);e.add("normalTextured",k);e.add("highlight",q);e.add("highlightTextured",b);d.add("fsDepth",{source:a.fsDepth});d.add("fsDepthTextured",{source:a.fsDepthTextured});d.add("fsDepthShadowMap",
{source:a.fsDepthShadowMap,defines:["BIAS_SHADOWMAP 1"]});d.add("fsDepthTexturedShadowMap",{source:a.fsDepthTextured,defines:["BIAS_SHADOWMAP 1"]});d.add("vsDepth",{source:a.vsDepth});d.add("fsNormal",{source:a.fsNormal})};return w});